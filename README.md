# nginx-infra-pipeline

A fully automated infrastructure pipeline that provisions EC2 instances on AWS using Terraform and deploys Nginx on them using Ansible — all triggered from a Jenkins pipeline.

---

## Architecture

```
Jenkins Server (pre-existing)
        │
        │  Pipeline triggers
        ▼
┌─────────────────────────────────────────┐
│              AWS Cloud                  │
│                                         │
│  Terraform creates:                     │
│  - Security Group                       │
│  - Key Pair (from Jenkins SSH key)      │
│  - EC2 Instances                        │
│  - Ansible inventory file (private IPs) │
│                                         │
│  Ansible deploys:                       │
│  - Nginx installed                      │
│  - Nginx started and enabled            │
└─────────────────────────────────────────┘
```

---

## Prerequisites

### 1. Jenkins Server
You need a running Jenkins server. If you don't have one:
- Launch an EC2 instance (Amazon Linux 2023 recommended)
- Run `bash jenkins_server_setup.sh` to install all required tools
- Open port **8080** in the security group for Jenkins UI
- Open port **22** for SSH access

### 2. AWS Permissions
Attach an IAM Role to your Jenkins EC2 with these policies:
- `AmazonEC2FullAccess`
- `AmazonVPCReadOnlyAccess`

### 3. Tools on Jenkins Server
The setup script handles all of these:
- Git
- Terraform
- Ansible
- SSH key pair for jenkins user

---

## Project Structure

```
nginx-infra-pipeline/
├── jenkins_server_setup.sh     ← one time Jenkins server setup script
├── Jenkinsfile                 ← pipeline definition
├── terraform/
│   ├── provider.tf             ← AWS provider configuration
│   ├── main.tf                 ← root module, calls child modules
│   ├── variables.tf            ← input variable declarations
│   ├── outputs.tf              ← output values
│   ├── terraform.tfvars        ← your configuration values
│   ├── inventory.tpl           ← template for Ansible inventory
│   └── modules/
│       ├── ec2/
│       │   ├── main.tf         ← EC2 instance resource
│       │   ├── variables.tf    ← EC2 module inputs
│       │   └── outputs.tf      ← EC2 module outputs
│       └── security_group/
│           ├── main.tf         ← Security group resource
│           ├── variables.tf    ← SG module inputs
│           └── outputs.tf      ← SG module outputs
└── ansible/
    ├── ansible.cfg             ← Ansible configuration
    ├── nginx_playbook.yml      ← Nginx installation playbook
    └── inventory.ini           ← auto generated by Terraform (gitignored)
```

---

## Setup Guide

### Step 1 — Run Jenkins server setup (first time only)
SSH into your Jenkins server and run:
```bash
bash jenkins_server_setup.sh
```

This will install Git, Terraform, Ansible, and generate an SSH key for the jenkins user. At the end it prints the **public key** — save it, you'll need it in the next step.

### Step 2 — Configure Terraform
Edit `terraform/terraform.tfvars` with your values:
```hcl
aws_region      = "<your-aws-region>"          # e.g. us-east-1, ap-south-1
project_name    = "<your-project-name>"        # e.g. my-app, nginx-infra
instance_count  = 2                            # number of nginx servers
instance_type   = "<your-instance-type>"
key_name        = "<your-key-pair-name>"       # name for the key pair in AWS
public_key_path = "/var/lib/jenkins/.ssh/id_rsa.pub"  # do not change
```

### Step 3 — Attach IAM Role to Jenkins EC2
- Go to AWS Console → IAM → Roles → Create Role
- Trusted entity: **EC2**
- Attach: `AmazonEC2FullAccess` and `AmazonVPCReadOnlyAccess`
- Go to EC2 → Jenkins instance → Actions → Security → Modify IAM Role → attach the role

### Step 4 — Configure Jenkins Pipeline
- Open Jenkins UI at `http://<jenkins-ip>:8080`
- Click **New Item** → **Pipeline**
- Under **Pipeline** select **Pipeline script from SCM**
- SCM: **Git**
- Repository URL: your repo URL
- Branch: `main`
- Script Path: `Jenkinsfile`
- Save

### Step 5 — Run the Pipeline
- Click **Build with Parameters**
- Select **ACTION**: `apply`
- Click **Build**

---

## Pipeline Stages

```
apply action:
├── Checkout          → pulls latest code from Git
├── Terraform Init    → initializes providers and modules
├── Terraform Plan    → shows what will be created
├── Terraform Apply   → creates EC2 instances, SG, Key Pair
│                       generates ansible/inventory.ini
├── Wait              → 60s for EC2 instances to fully boot
└── Ansible Playbook  → installs, starts, and verifies Nginx

destroy action:
├── Checkout
├── Terraform Init
├── Terraform Plan
└── Terraform Destroy → destroys all created AWS resources
```

---

## Configuration Reference

| Variable | Description | Default |
|---|---|---|
| `aws_region` | AWS region to deploy into | `us-east-1` |
| `project_name` | Name prefix for all resources | `nginx-infra` |
| `instance_count` | Number of nginx servers | `2` |
| `instance_type` | EC2 instance type | `t3.micro` |
| `key_name` | AWS key pair name | `jenkins-key` |
| `public_key_path` | Path to jenkins user public key | `/var/lib/jenkins/.ssh/id_rsa.pub` |

---

## How It Works

### Terraform
- Fetches the latest **Amazon Linux 2023 AMI** automatically (region agnostic)
- Cycles through valid **Availability Zones** for the chosen instance type to avoid AZ limitations
- Creates a **Security Group** allowing SSH (22) and HTTP (80)
- Uploads the **Jenkins user's public key** to AWS as a key pair
- Launches EC2 instances with the key pair attached
- Uses `templatefile()` to generate `ansible/inventory.ini` with private IPs

### Ansible
- Reads `inventory.ini` generated by Terraform
- SSHes into each server using the jenkins user's private key
- Installs Nginx using `dnf`
- Starts and enables Nginx via systemd
- Verifies Nginx is running and prints status

### Jenkins
- Pulls code from Git on every run
- Parameterized pipeline — choose `apply` or `destroy`
- `apply` runs Terraform + Ansible
- `destroy` only runs Terraform destroy
- Uses IAM role on the Jenkins EC2 for AWS authentication (no hardcoded keys)

---

## Destroying Infrastructure
When you're done, destroy all AWS resources:
- Click **Build with Parameters**
- Select **ACTION**: `destroy`
- Click **Build**

This destroys all EC2 instances, security groups, and key pairs created by Terraform.

---

## Future Improvements
- Move nginx servers to a private subnet with NAT gateway
- Add a Load Balancer in front of nginx servers
- Store Terraform state remotely using S3 backend
- Add manual approval stage in Jenkins before apply